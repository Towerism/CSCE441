* CSCE 441-500 
Notes for Computer Graphics
* Course info
- Website [[http://faculty.cs.tamu.edu/jchai/csce441_2016spring]]
- Lecture is more important than the textbook
** Staff
- Dr. Jinxian Chai HRBB 527D (MW 1:30-2:30pm) also by appointment
- Grader: Chaitanya Visveswara (chaitu236@tamu.edu)
- TAs Jianjie Zhang & Fuhao Shi HRBB 505 (jjzhang10@tamu.edu)
- Send emails to both TA and Prof
** Submissions
- CSNet
- Due midnight on day specified
- Source and Win32 executable
- Comment your unreadable code
- No team coding
** Grading
- 60% Assignments
- 15% Midterm
- 25% Final
** Applications
*** Games
*** Movies
*** Visualization
*** Industrial Design
-* Virtual cars,
-* Environments,
-* Aircraft, etc
*** Human computer interactions
-* Microsoft's Kinect for Xbox 360 and Xbox One
*** Realworld Modeling
-* Google Earth
-* Build a model, then render an image from a particular (perhaps different) viewpoint
*** 3D Printing
-* Design 3D object in virtual environment, then print it
*** Visual Data Processing
- Image and Video processing
- Manipulating objects in a virtual space
  - Compose images and models
  - Synthesis the missing background
  - Transform pictures
** Expect to learn
Using OpenGL in programming assignments
*** 2D Graphics
-* Drawing lines, polygons
-* Image processing
*** 3D Graphics
- Transformations
- Lighting
- Ray Tracing (popular in global lighting techniques)
- Geometric Modeling
- Splines
- Animation
** Expected to know
*** Programming Experience
A*ssignments are in C/C++
*** Simple Mathematics
** How much math?
*** General geometry/linear algebra
*** Matrices
-* Multiplication
-* Inversion
-* Determinant
*** Vectors
- Dot product,
- Cross product, linear independence
** Linear Algebra Test
- See todo for deadline
- [[http://projects.cs.tamu.edu/keyser/LAtest/]]
- Need 90% correct by deadline, or will get a 0 for the class
* Into to OpenGL
** What?
*** Computer graphics API
- Developed by SGI in 1992
- Efficient, streaming interface
- 250+ function calls for drawing 2D and 3D graphics
- Hardware independent
- OS independent
- Competes against direct3D from microsoft
  - OpenGL seems to be more popular because it is OS independent
** What it is not
- No commands for windowing
- No commands for obtaining user input
- No commands for anything except drawing on the screen
** Command Formats
- Prefix (e.g. gl)
- Initial capital letters
- Number of components
  - 2: (x, y)
  - 3: (x, y, z)
  - 4: (x, y, z, w)
- Data type
- Vector
** Geogetric Primitives
See documentation for better descriptions
- GL_POINTS
- GL_TRIANGLE_STRIP
- GL_TRIANGLES
  - Each triad of vertices defines a triangle
- GL_LINES
  - Each pair of vertices constitutes a line
- GL_LINE_STRIP
  - Connect each vertex to the previous one
- GL_TRIANBLE_FAN
- GL_LINE_LOOP
  - Like STRIP except the first and last points are connected
- GL_QUADS
- GL_QUAD_STRIP
- GL_POLYGON
* Related Libraries
** GLU (OpenGL Utility Library)
- Part of OpenGL
- Provides higher-level drawing routines such as
  - Spheres,
  - NURBS,
  - Tesselators,
  - Quadric shapes, etc.
** GLUT (GLU Toolkit)
- perform system level IO with host os
- cross platform
- protable window API
* Scan Conversion of Lines
** Line-drawing using "Paint"
** How can we represent and display images
*** Image representation
**** An image is a 2D rectilinear array of pixels
- width*height array where each entry of the array stores a single pixel
- each pixel stores color information
*** Displays
  - LCD
- Oculus
- Smartphone
**** Pixels
- Smallest element of picture
- Integer position (i, j)
- Color information (r, g, b)
***** Luminance pixels
- Gray-scale images (intensity images)
- 0-1.0 or 0-255
- 8 bits per pixel (bpp)
***** Red, green, pixels (RGB)
- Color images
- Each channel: 0-1.0 or 0-255
- 24 bpp
** Digital Scan Conversion
- Convert graphics output primitives into a set of pixel values for storage in
  the frame buffer
- Store image info in the frame buffer
- Display on screen based on what is stored in frame buffer
** How to draw a line
*** Problem
- Given two points (P, Q) on the screen (with int coordinates) determine which
  pixels should be drawn to display a unit width line
**** Idea is to interpolate pixel values through rounding based on a perfect straight-through line (DDA)
***** Special lines
- Horizontal (y is constant)
- Vertical (x is constant)
- Diagonal (increment both)
***** Arbitrary lines
****** Slope-intercept equation for a line
$y = mx + b$
****** Focus on line with slope between 0 to 1
- Manipulate line equation to satisfy this property
*** Digital DIfferential Analyzer (DDA)
- Sample unit intervals in one coordinate
  - e.g. inc x by 1, inc y by m
- Find nearest pixel for each sampled point
**** Limitations
- Floating point operations (slow)
- Rounding (slow)
- Can we do better?
*** Midpoint algorithm
- Next pixel to draw is always East or Northeast from the current pixel
- Given a point, determinte whether the next pixel is E or NE
- Is the line above or below the midpoint (x + 1, y + 1/2)
  - Below: move E
  - Above: move NE
**** Implementation issues
***** How to eval if the midpoint is above or below the line
- properties
  - $y=mx+b (x,y)$ on the line
  - $y<mx+b (x,y)$ below the line
  - $y>mx+b (x,y)$ above the line
- Manipulate $f(x,y) = y-mx-b$ to achieve integers $c,d,e$
  - $f(x,y)=cx+dy+e$
  - if $f(x,y)<0$, then the point is below the line
  - similarly for > and =
***** How to incrementally eval this
- Incremental update to speed up the algorithm
- Fancy discrete math proofs and manipulations
- Need value of $f(x + 1, y + 1/2)$ to determine E or NE
- Build incremental algorithm
- Assume we have a value of $f(x+1, y+1/2)$
  - Find value of $f(x+2, y+1/2)$ if E is chosen
  - Find value of $f(x+2, y+3/2)$ if NE is chosen
***** How to avoid floating point ops
- Just a bunch of plugging into f(x,y), expanding, and simplifying
**** Advantages 
- Only integer operations
*** Midpoint Algorithm: Circle
- Similar idea: but the possible directions seem to change
** Required reqdings
HB 6.1-6.8 (remember ppt more important) 
