* CSCE 441-500 
Notes for Computer Graphics
* Course info
- Website [[http://faculty.cs.tamu.edu/jchai/csce441_2016spring]]
- Lecture is more important than the textbook
** Staff
- Dr. Jinxian Chai HRBB 527D (MW 1:30-2:30pm) also by appointment
- Grader: Chaitanya Visveswara (chaitu236@tamu.edu)
- TAs Jianjie Zhang & Fuhao Shi HRBB 505 (jjzhang10@tamu.edu)
- Send emails to both TA and Prof
** Submissions
- CSNet
- Due midnight on day specified
- Source and Win32 executable
- Comment your unreadable code
- No team coding
** Grading
- 60% Assignments
- 15% Midterm
- 25% Final
** Applications
*** Games
*** Movies
*** Visualization
*** Industrial Design
-* Virtual cars,
-* Environments,
-* Aircraft, etc
*** Human computer interactions
-* Microsoft's Kinect for Xbox 360 and Xbox One
*** Realworld Modeling
-* Google Earth
-* Build a model, then render an image from a particular (perhaps different) viewpoint
*** 3D Printing
-* Design 3D object in virtual environment, then print it
*** Visual Data Processing
- Image and Video processing
- Manipulating objects in a virtual space
  - Compose images and models
  - Synthesis the missing background
  - Transform pictures
** Expect to learn
Using OpenGL in programming assignments
*** 2D Graphics
-* Drawing lines, polygons
-* Image processing
*** 3D Graphics
- Transformations
- Lighting
- Ray Tracing (popular in global lighting techniques)
- Geometric Modeling
- Splines
- Animation
** Expected to know
*** Programming Experience
A*ssignments are in C/C++
*** Simple Mathematics
** How much math?
*** General geometry/linear algebra
*** Matrices
-* Multiplication
-* Inversion
-* Determinant
*** Vectors
- Dot product,
- Cross product, linear independence
** Linear Algebra Test
- See todo for deadline
- [[http://projects.cs.tamu.edu/keyser/LAtest/]]
- Need 90% correct by deadline, or will get a 0 for the class
* Into to OpenGL
** What?
*** Computer graphics API
- Developed by SGI in 1992
- Efficient, streaming interface
- 250+ function calls for drawing 2D and 3D graphics
- Hardware independent
- OS independent
- Competes against direct3D from microsoft
  - OpenGL seems to be more popular because it is OS independent
** What it is not
- No commands for windowing
- No commands for obtaining user input
- No commands for anything except drawing on the screen
** Command Formats
- Prefix (e.g. gl)
- Initial capital letters
- Number of components
  - 2: (x, y)
  - 3: (x, y, z)
  - 4: (x, y, z, w)
- Data type
- Vector
** Geogetric Primitives
See documentation for better descriptions
- GL_POINTS
- GL_TRIANGLE_STRIP
- GL_TRIANGLES
  - Each triad of vertices defines a triangle
- GL_LINES
  - Each pair of vertices constitutes a line
- GL_LINE_STRIP
  - Connect each vertex to the previous one
- GL_TRIANBLE_FAN
- GL_LINE_LOOP
  - Like STRIP except the first and last points are connected
- GL_QUADS
- GL_QUAD_STRIP
- GL_POLYGON
* Related Libraries
** GLU (OpenGL Utility Library)
- Part of OpenGL
- Provides higher-level drawing routines such as
  - Spheres,
  - NURBS,
  - Tesselators,
  - Quadric shapes, etc.
** GLUT (GLU Toolkit)
- perform system level IO with host os
- cross platform
- protable window API
* Scan Conversion of Lines
** Line-drawing using "Paint"
** How can we represent and display images
*** Image representation
**** An image is a 2D rectilinear array of pixels
- width*height array where each entry of the array stores a single pixel
- each pixel stores color information
*** Displays
  - LCD
- Oculus
- Smartphone
**** Pixels
- Smallest element of picture
- Integer position (i, j)
- Color information (r, g, b)
***** Luminance pixels
- Gray-scale images (intensity images)
- 0-1.0 or 0-255
- 8 bits per pixel (bpp)
***** Red, green, pixels (RGB)
- Color images
- Each channel: 0-1.0 or 0-255
- 24 bpp
** Digital Scan Conversion
- Convert graphics output primitives into a set of pixel values for storage in
  the frame buffer
- Store image info in the frame buffer
- Display on screen based on what is stored in frame buffer
** How to draw a line
*** Problem
- Given two points (P, Q) on the screen (with int coordinates) determine which
  pixels should be drawn to display a unit width line
**** Idea is to interpolate pixel values through rounding based on a perfect straight-through line (DDA)
***** Special lines
- Horizontal (y is constant)
- Vertical (x is constant)
- Diagonal (increment both)
***** Arbitrary lines
****** Slope-intercept equation for a line
$y = mx + b$
****** Focus on line with slope between 0 to 1
- Manipulate line equation to satisfy this property
*** Digital DIfferential Analyzer (DDA)
- Sample unit intervals in one coordinate
  - e.g. inc x by 1, inc y by m
- Find nearest pixel for each sampled point
**** Limitations
- Floating point operations (slow)
- Rounding (slow)
- Can we do better?
*** Midpoint algorithm
- Next pixel to draw is always East or Northeast from the current pixel
- Given a point, determinte whether the next pixel is E or NE
- Is the line above or below the midpoint (x + 1, y + 1/2)
  - Below: move E
  - Above: move NE
**** Implementation issues
***** How to eval if the midpoint is above or below the line
- properties
  - $y=mx+b (x,y)$ on the line
  - $y<mx+b (x,y)$ below the line
  - $y>mx+b (x,y)$ above the line
- Manipulate $f(x,y) = y-mx-b$ to achieve integers $c,d,e$
  - $f(x,y)=cx+dy+e$
  - if $f(x,y)<0$, then the point is below the line
  - similarly for > and =
***** How to incrementally eval this
- Incremental update to speed up the algorithm
- Fancy discrete math proofs and manipulations
- Need value of $f(x + 1, y + 1/2)$ to determine E or NE
- Build incremental algorithm
- Assume we have a value of $f(x+1, y+1/2)$
  - Find value of $f(x+2, y+1/2)$ if E is chosen
  - Find value of $f(x+2, y+3/2)$ if NE is chosen
***** How to avoid floating point ops
- Just a bunch of plugging into f(x,y), expanding, and simplifying
**** Advantages 
- Only integer operations
*** Midpoint Algorithm: Circle
- Similar idea: but the possible directions seem to change
** Required reqdings
HB 6.1-6.8 (remember ppt more important)
* Scan Conversion of Polygons
** Drawing General Polygons
*** Drawing Rectangles
**** How to avoid overlap?
- *RULE* In this class do *not* draw pixels on the *top* and *right* of the
  rectangle
- Benefit: we never draw the same pixel twice
- There are some limitations
*** How to draw every interior pixel?
- process the scan line from the bottom of the boundaries to the top
**** draw every interior pixel for each scan line
- including pixels intersecting the boundary
- you only draw pixels at "odd" intervals
  - The first interval is defined by the first and second intersection point
  - Next interval is defined by the second and third intersection point etc.
**** Once again follow the rule for avoiding overlapping polygons
**** Overview
***** Intersect scan lines with edges 
- use *coherence* to speed up
  - using the relationship between two intersecting scan lines and the polygon
    edge
***** Find ranges along x
***** Fill interior of those ranges
***** Draw odd intervals only
*** How to store polygon edges?
**** Sorted Edge Tables
- Associate polygon edges with scan lines
- Find out the low end point for each and correlate it with a corresponding
  scanline
- Store the multiple edges associated with each scanline as a linked list
- Exclude horizontal edges
*** Represent edges intersecting current scanline
**** Active Edge List
- List of all edges intersecting current scan-line sorted by their x-values
- Each edge is stored with the following information
| Edge     | Description                              |
|----------+------------------------------------------|
| maxY     | highest y-value                          |
| currentX | x-value of end-point with lowest y-value |
| xIncr    | 1 / slope                                |

*** Algorithm
#+BEGIN_SRC
line = 0
While (line < height)
  Add edges to active edge list from sorted edge table starting at line
    Table sfarting at line
  Remove edges with a maxY equal to currentX
  Fill interior pixels // draw pixels the curreent scan line
  Increment x-values on edges in Active Edge list
  Increment line
#+END_SRC
** Drawing Curved Objects
Neither mid-term or final will test on this!
*** How to draw every interior pixel?
- process the scan line from the bottom to top
- find the intersection positions between the current scan line and the
  boundaries of fill region
- use coherence properties to reduce the process
- fill interior pixel in the odd intervals
** Methods for drawing polygons or curved objects
*** Scanline conversion of polygons
*** Boundary fill (boundary is one color)
- Start with drawn boundaries and an interior point
- Recursively recolor outward from that point
  - If neighbor is different, then recolor and recur
- Everyting within the boundary is changed to that color
*** flood fill (boundary may be different colors)
- Start with a point
- Define color under that point sas the interior color
- Recursively recolor outward from that poing
  - If neighbor is interior color, then recolor and recur
- Contiguous regions are re-colored
*** Boundary vs Flood-fill
- Both start with an interior pixel
- Boundary-fill requires annotating boundary pixels while flood-fill requires
  annotating interior pixels
- Both are appealing to fill in the irregular boundaries
** Reading
- 6-10 and 10-14
* Clipping lines
** Why Clip?
- Do not want to waste time drawing objects that are outside of the viewing
  window (or clipping window)
** Clipping points
- Given a point (x, y) and clipping window (xmin, ymin), (xmax, ymax)
- Determine if the point should be drawn
** Clipping lines
- Given a line with end-points (x0, y0), (x1, y1) and clipping window (xmin,
  ymin), (xmax, ymax)
- Determine
  - whether line should be drawn
  - clipped end-points of line to draw
** Simple Alg
- If both end points inside rect, draw line
- If one end-point outside,
- Intersect line with all edges of rectangle
  - clip the line segment outside the rect, and repeat test with rest of edges
*** Intersecting two lines
- parametric representation of the lines
  - t = 0 corresponds to (x0,y0)
  - t = 1 correspons to (x1, y1)
- Have a system of parametric equations to determine if there is an
  intersection and also to calculate the point of intersection
*** Disadvantages
- Lots of intersection tests makes alg expensive
- Complicated tests to determine if intersecting rectangle
- Is there a better way?
**** Trivial accepts
- big optimization
- How can we quickly decide whether the line segment is entirely inside window
- Answer: test both endpoints
**** Trivial rejects
- How to know if a line is outside of the window
- Answer: both endpoints on wrong side of the same edge, can trivially reject
  the line
** Cohen-Sutherland
*** Classify p0, p1 using region codes c0, c1
- Every end point is assigned to a four-digit binary value, i.e. region code
- Each bit position indicates whether the point is inside or outside of a
  specific window edges
| bit 4 | bit 3  | bit 2 | bit 1 |
|-------+--------+-------+-------|
| top   | bottom | right | left  |

| 1001 | 1000 | 1010 |
| 0001 | 0000 | 0010 |
| 0101 | 0100 | 0110 |
**** If c0 ^ c1 not 0
- bitwise and 0010 ^ 1011 = 0010
- trivially reject
**** If c0 bitwise or c1 not 0
- trivially accept because both points are not on wrong side for any edge
- bitwise or 0010 op 1011 = 1011
**** Otherwise reduce to trivial cases by splitting into two segments
*** Window intersection
- Similar to simple alg
*** Extends easiy to 3D line clipping
- 27 regions
- 6 bits
*** Summarize
- Use region codes to quickly eliminate/incude lines
  - *best algorithm when trivial accepts/rejects are common*
- Must compute viewing window clipping of remaining lines
- More efficient algs exist
  - non-trivial clipping cost
** Liang-Barsky
*** Parametric definition of a line
- x = x1 udeltax
- y = y1 udeltay
- deltax = (x2-x1)
- deltay = (y2-y1), 0<=u<=1
*** Lines are oriented: classify lines as moving inside to out or outside to in
- For lines stating outside, update its starting point
- For lines starting inside, update end point
- For lines paralleling the boundaries and outside, reject it
*** Goal find range of u for which x and y both inside the viewing window
*** Advantages
- Faster than cohen-sutherland
- Extension to 3D is easy
  - parametric rep for 3D lines
  - Compute u1, u2 based on the intersection between ine and plane
** More Complex clipping windows
- The clipping could be any polygon
- Both Cohen and Liang can be extended to any polygon as well curve clipping
** Required reqdings: HB 8-5, 8-6, 8-7, and 8-9
* Clipping polygons
** Why is clippping hard?
- Consider the result of clipping a triangle
  - May be a triangle
  - Or some other polygon such as a 7-gon (7 is the max for a triangle)
- Tough cases such as concave polygons
** Sutherland-Hodgman Clipping
- *convex polygons*
*** Idea
- Apply line clipping to each edge of polygon
- But we may get unconnected lines which is undesirable
- *Basic idea* similar to line clipping
  - Clip against each edge of the window
  - This way the clipped polygon would be connected along the window edges
*** Input/Output for algorithm
- input: list of polygon vertices *in order*
- output: list of clipped polygon vertices consisting of old vertices (maybe)
  and new vertices (maybe)
*** How to clip against window edge
- Go around polygon one vertex (i.e. polygon edge) at a time
- Current vertex has position E
- Previous vertex had position S, and it has been added to the output if appropriate
- *Need to determine output vertices for each polygon lines*
**** Four cases
- both inside S to E
  - include E
- outside to inside S to E
  - include E plus intersection
- inside to outside S to E
  - include intersection
- both outside S to E
  - exclude both
*** Dealing with non-convex polygons
1. split concave polygon into two or more convex polygons (see sec 4-7)
2. use more general polygon clipper
3. perform the algorithm plus post-processing
*** Dealing with more general clipping boundaries
- Do polygon clipping against each boundary edge
*** Summary
- Works for convex input polygons
- Works for convex clipping boundaries
- Easy to pipeline for parallel processing
- Polygon from one boundary does not have to be completed before next boundary starts
** Weiler-Atherton 
- *general polygons*
*** Idea
- trace around perimeter of the fill polygon
- search for the borders that enclose a clipped fill region
*** Procedure
1. process the edges of the polygon fill area in a CCW order until an
   inside-outside pair of vertices is encountered
2. Follow the window boundaries in a CCW direction from the exit-intersection point to
   another intersection point with the polygon
   - *previously processed?*
   - if yes: go to next step
   - if no: continue processing polygon until a previously encountered point is
     encountered
3. Form the vertex list for this section of the clipped area
4. Return to exit-intersection point and continue processing polygon edges in a
   CCW order until another inside-outside pair of vertices is encountered
*** Summary
- Works for general input polygons (concave and convex)
- Handles a clipping window with any polygon shape (concave and convex)
- Can be extended to 3D
- Not as efficient as Sutherland-Hodgman
- Not as efficient as Sutherland-Hodgman
- Not easy to parallelize
** Nonlinear clipping-window boundaries
- Approximate the boundaries with straight-line sections
- Use the existing polygon clipping algorithms for clipping against a general
  polygon-shaped clipping window
** Required readings
HB 8-8
* 2D Transformations
** Point Representation
- We can use a column vector (a 2x1 matrix) to represent a 2D point (x, y).
- A general form of /linear/ transformation can be written as
\[
x' = ax + by + c
\]
or
\[
y' = dx + ey + f
\]
- Transformations can be written as a matrix, vector multiplication.
** Translate
- Re-position a point along a straight line
- Given a point (x, y), and the translation distance (tx, ty).
| x' |   | 1 | 0 | tx |   | x |
| y' | = | 0 | 1 | ty | * | y |
| 1  |   | 0 | 0 | 1  |   | 1 |
- How to translate an object with multiple vertices?
  - Translate each vertex individually
** Rotate
*** About the origin
- Default rotation center: Origin (0, 0)
- For theta
  - >0: Rotate counter clockwise
  - <0: Rotate clockwise
- Rotate (x, y) /about the origin/ by theta
  - Result: (x', y')
- Use trig to calculate the angle to rotate (x, y) to get (x', y')
- Matrix form
| x' |   | cos theta | -sin theta | 0 |   | x |
| y' | = | sin theta | cos theta  | 0 | * | y |
| 1  |   | 0         | 0          | 1 |   | 1 |
*** About any point 
- Idea
  - Translate the rotation center to the origin
  - Perform the rotation
  - Translate it back
| x' |   | 1 | 0 | px |   | cos theta | -sin theta | 0 |   | 1 | 0 | -px |   | x |
| y' | = | 0 | 1 | py | * | sin theta | cos theta  | 0 | * | 0 | 1 | -py | * | y |
| 1  |   | 0 | 0 | 1  |   | 0         | 0          | 1 |   | 0 | 0 | 1   |   | 1 |
** Scale
- Alter the size of an object by a scaling factor (Sx, Sy)
- Apply scaling to each vertex
- For now, translation will also occur
  - Consider scaling without translation
| x' |   | Sx |  0 | 0 |   | x |
| y' | = |  0 | Sy | 0 | * | y |
| 1  |   |  0 |  0 | 1 |   | 1 |
*** Without translation
| x' |   | 1 | 0 | px |   | Sx |  0 | 0 |   | 1 | 0 | -px |   | x |
| y' | = | 0 | 1 | py | * |  0 | Sy | 0 | * | 0 | 1 | -py | * | y |
| 1  |   | 0 | 0 | 1  |   |  0 |  0 | 1 |   | 0 | 0 | 1   |   | 1 |
** Shearing
- in x
| x' |   | 1 | h | 0 |   | x |
| y' | = | 0 | 1 | 0 | * | y |
| 1  |   | 0 | 0 | 1 |   | 1 |
- in y
| x' |   | 1 | 0 | 0 |   | x |
| y' | = | g | 1 | 0 | * | y |
| 1  |   | 0 | 0 | 1 |   | 1 |
*** Interesting facts
- A 2d rot is three shears
- Shearing will not change the area of the object
- Any 2d shearing can be done by a rotation, followed by a , follow by a .
** Reflection
- About X-axis
| x' |   | 1 |  0 | 0 |   | x |
| y' | = | 0 | -1 | 0 | * | y |
| 1  |   | 0 |  0 | 1 |   | 1 |
- About Y-axis
| x' |   | -1 | 0 | 0 |   | x |
| y' | = |  0 | 1 | 0 | * | y |
| 1  |   |  0 | 0 | 1 |   | 1 |
- About origin
| x' |   | -1 |  0 | 0 |   | x |
| y' | = |  0 | -1 | 0 | * | y |
| 1  |   |  0 |  0 | 1 |   | 1 |
*** About an arbitrary line
Idea, rotate, reflect, rotate back (similar to above arbitrary methods)
** Affine Transformation
- Translation, scaling, rotation, shearing are all affine transformations
- Affine transformation - transformed point is a linear combination of the
  original points
- Essentially using basic transformations to obtain a composite matrix to
  describe a complex transformation
*** How to find affine transformations
- How many points needed to estimate affine transformation?
- Three because you have two equations for each correspondent
- 6 unknowns
| x' |   | m11 | m12 | m13 |   | x |
| y' | = | m21 | m22 | m23 | * | y |
| 1  |   | 0   | 0   | 1   |   | 1 |
** Composing transformation
- Composing transformation - the process of applying several transformations in succession to
  form done overall trans
- The arbitrary methods above, can use pre-multiplication to get a composite
  transformation matrix
*** Order is important
- Matrix multiplication is associative
- Transformation products may not be commutative!
- Example: rotation and translation are not commutative
**** Some cases where it does not matter
- translation
- scaling
- rotation
** Why use 3x3 Matrices?
- So that we can use matrix, vector multiplication for all transformations
- This allows us to pre-multiply all the matrices together
- The point (x, y) needs to be represented as (x,y,1)
  - This is call *homogeneous coordinates*
  - How to represent a vector (v_x, v_y)?
    - (v_x, v_y, 0)
  - Remember,
    - for *point* the homogeneous coordinate is 1
    - for *vector* it is 0
** Applications
*** Animation
*** Image/object manipulation
*** Viewing transformation
* 3D Transformations
- A 3D point (x,y,z) - x,y, and z coordinates
- we will still use column vectors to represent points
- Homogeneous coordinates of a 3D point (x,y,z,1)
- Transformation will be performed using a 4x4 matrix
** Right-handed Coordinate System
$x*y=z$; $y*z=x$; $z*x=y$
** Translation
** Rotation
- 3D rotation is done around a rotation *axis*
- Fundamental rotations - rotate about x, y, or z axes
- CCW rotation is referred to as positive rotation (when you look down negative axis)
- Keep the axis of rotation constant
  - Replacement
  - I.e. treat the other two axes as if they are x and y axes in 2d rotation
*** Arbitrary axis
- Set up a transformation that superimposes rotation axis onto one coordinate axis
- Rotate about the coordinate axis
- Translate and rotate object back via inverse of the initial transformation
- The resulting composite matrix is *orthonormal*
  - column rows linearly independent *orthogonal*
  - column rows are unit vectors *normalized*
  - inverse of the matrix is its transpose
** Scaling
- Very similar to 2d transformation
** Inverse of 3D transformations
- Invert the transformation matrix
* Coordinate transformation
- Coordinate transformation from one reference frame to another
** Review
- Dot product: angle between two vectors
- Cross product: area determined by two vectors
** 2D Cartesian coordinate system
- Axes described by unit vectors i and j.
  - $i \cdot i = 1$
  - $j \cdot j = 1$
  - $i \cdot j = 0$
- Any 2D vector can be represented as xi + yj
- Any 2D vector starting from the origin can be described as $op = xi + yj$
*** Transform object description
- from $i'j'$ to $ij$
- Use composite matrix which performs a possible rotation and a possible
  translation
** Object
** World
** View
