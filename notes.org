* CSCE 441-500 
Notes for Computer Graphics
* Course info
- Website [[http://faculty.cs.tamu.edu/jchai/csce441_2016spring]]
- Lecture is more important than the textbook
** Staff
- Dr. Jinxian Chai HRBB 527D (MW 1:30-2:30pm) also by appointment
- Grader: Chaitanya Visveswara (chaitu236@tamu.edu)
- TAs Jianjie Zhang & Fuhao Shi HRBB 505 (jjzhang10@tamu.edu)
- Send emails to both TA and Prof
** Submissions
- CSNet
- Due midnight on day specified
- Source and Win32 executable
- Comment your unreadable code
- No team coding
** Grading
- 60% Assignments
- 15% Midterm
- 25% Final
** Applications
*** Games
*** Movies
*** Visualization
*** Industrial Design
-* Virtual cars,
-* Environments,
-* Aircraft, etc
*** Human computer interactions
-* Microsoft's Kinect for Xbox 360 and Xbox One
*** Realworld Modeling
-* Google Earth
-* Build a model, then render an image from a particular (perhaps different) viewpoint
*** 3D Printing
-* Design 3D object in virtual environment, then print it
*** Visual Data Processing
- Image and Video processing
- Manipulating objects in a virtual space
  - Compose images and models
  - Synthesis the missing background
  - Transform pictures
** Expect to learn
Using OpenGL in programming assignments
*** 2D Graphics
-* Drawing lines, polygons
-* Image processing
*** 3D Graphics
- Transformations
- Lighting
- Ray Tracing (popular in global lighting techniques)
- Geometric Modeling
- Splines
- Animation
** Expected to know
*** Programming Experience
A*ssignments are in C/C++
*** Simple Mathematics
** How much math?
*** General geometry/linear algebra
*** Matrices
-* Multiplication
-* Inversion
-* Determinant
*** Vectors
- Dot product,
- Cross product, linear independence
** Linear Algebra Test
- See todo for deadline
- [[http://projects.cs.tamu.edu/keyser/LAtest/]]
- Need 90% correct by deadline, or will get a 0 for the class
* Into to OpenGL
** What?
*** Computer graphics API
- Developed by SGI in 1992
- Efficient, streaming interface
- 250+ function calls for drawing 2D and 3D graphics
- Hardware independent
- OS independent
- Competes against direct3D from microsoft
  - OpenGL seems to be more popular because it is OS independent
** What it is not
- No commands for windowing
- No commands for obtaining user input
- No commands for anything except drawing on the screen
** Command Formats
- Prefix (e.g. gl)
- Initial capital letters
- Number of components
  - 2: (x, y)
  - 3: (x, y, z)
  - 4: (x, y, z, w)
- Data type
- Vector
** Geogetric Primitives
See documentation for better descriptions
- GL_POINTS
- GL_TRIANGLE_STRIP
- GL_TRIANGLES
  - Each triad of vertices defines a triangle
- GL_LINES
  - Each pair of vertices constitutes a line
- GL_LINE_STRIP
  - Connect each vertex to the previous one
- GL_TRIANBLE_FAN
- GL_LINE_LOOP
  - Like STRIP except the first and last points are connected
- GL_QUADS
- GL_QUAD_STRIP
- GL_POLYGON
* Related Libraries
** GLU (OpenGL Utility Library)
- Part of OpenGL
- Provides higher-level drawing routines such as
  - Spheres,
  - NURBS,
  - Tesselators,
  - Quadric shapes, etc.
** GLUT (GLU Toolkit)
- perform system level IO with host os
- cross platform
- protable window API
* Scan Conversion of Lines
** Line-drawing using "Paint"
** How can we represent and display images
*** Image representation
**** An image is a 2D rectilinear array of pixels
- width*height array where each entry of the array stores a single pixel
- each pixel stores color information
*** Displays
  - LCD
- Oculus
- Smartphone
**** Pixels
- Smallest element of picture
- Integer position (i, j)
- Color information (r, g, b)
***** Luminance pixels
- Gray-scale images (intensity images)
- 0-1.0 or 0-255
- 8 bits per pixel (bpp)
***** Red, green, pixels (RGB)
- Color images
- Each channel: 0-1.0 or 0-255
- 24 bpp
** Digital Scan Conversion
- Convert graphics output primitives into a set of pixel values for storage in
  the frame buffer
- Store image info in the frame buffer
- Display on screen based on what is stored in frame buffer
** How to draw a line
*** Problem
- Given two points (P, Q) on the screen (with int coordinates) determine which
  pixels should be drawn to display a unit width line
**** Idea is to interpolate pixel values through rounding based on a perfect straight-through line (DDA)
***** Special lines
- Horizontal (y is constant)
- Vertical (x is constant)
- Diagonal (increment both)
***** Arbitrary lines
****** Slope-intercept equation for a line
$y = mx + b$
****** Focus on line with slope between 0 to 1
- Manipulate line equation to satisfy this property
*** Digital DIfferential Analyzer (DDA)
- Sample unit intervals in one coordinate
  - e.g. inc x by 1, inc y by m
- Find nearest pixel for each sampled point
**** Limitations
- Floating point operations (slow)
- Rounding (slow)
- Can we do better?
*** Midpoint algorithm
- Next pixel to draw is always East or Northeast from the current pixel
- Given a point, determinte whether the next pixel is E or NE
- Is the line above or below the midpoint (x + 1, y + 1/2)
  - Below: move E
  - Above: move NE
**** Implementation issues
***** How to eval if the midpoint is above or below the line
- properties
  - $y=mx+b (x,y)$ on the line
  - $y<mx+b (x,y)$ below the line
  - $y>mx+b (x,y)$ above the line
- Manipulate $f(x,y) = y-mx-b$ to achieve integers $c,d,e$
  - $f(x,y)=cx+dy+e$
  - if $f(x,y)<0$, then the point is below the line
  - similarly for > and =
***** How to incrementally eval this
- Incremental update to speed up the algorithm
- Fancy discrete math proofs and manipulations
- Need value of $f(x + 1, y + 1/2)$ to determine E or NE
- Build incremental algorithm
- Assume we have a value of $f(x+1, y+1/2)$
  - Find value of $f(x+2, y+1/2)$ if E is chosen
  - Find value of $f(x+2, y+3/2)$ if NE is chosen
***** How to avoid floating point ops
- Just a bunch of plugging into f(x,y), expanding, and simplifying
**** Advantages 
- Only integer operations
*** Midpoint Algorithm: Circle
- Similar idea: but the possible directions seem to change
** Required reqdings
HB 6.1-6.8 (remember ppt more important)
* Scan Conversion of Polygons
** Drawing General Polygons
*** Drawing Rectangles
**** How to avoid overlap?
- *RULE* In this class do *not* draw pixels on the *top* and *right* of the
  rectangle
- Benefit: we never draw the same pixel twice
- There are some limitations
*** How to draw every interior pixel?
- process the scan line from the bottom of the boundaries to the top
**** draw every interior pixel for each scan line
- including pixels intersecting the boundary
- you only draw pixels at "odd" intervals
  - The first interval is defined by the first and second intersection point
  - Next interval is defined by the second and third intersection point etc.
**** Once again follow the rule for avoiding overlapping polygons
**** Overview
***** Intersect scan lines with edges 
- use *coherence* to speed up
  - using the relationship between two intersecting scan lines and the polygon
    edge
***** Find ranges along x
***** Fill interior of those ranges
***** Draw odd intervals only
*** How to store polygon edges?
**** Sorted Edge Tables
- Associate polygon edges with scan lines
- Find out the low end point for each and correlate it with a corresponding
  scanline
- Store the multiple edges associated with each scanline as a linked list
- Exclude horizontal edges
*** Represent edges intersecting current scanline
**** Active Edge List
- List of all edges intersecting current scan-line sorted by their x-values
- Each edge is stored with the following information
| Edge     | Description                              |
|----------+------------------------------------------|
| maxY     | highest y-value                          |
| currentX | x-value of end-point with lowest y-value |
| xIncr    | 1 / slope                                |

*** Algorithm
#+BEGIN_SRC
line = 0
While (line < height)
  Add edges to active edge list from sorted edge table starting at line
    Table sfarting at line
  Remove edges with a maxY equal to currentX
  Fill interior pixels // draw pixels the curreent scan line
  Increment x-values on edges in Active Edge list
  Increment line
#+END_SRC
** Drawing Curved Objects
Neither mid-term or final will test on this!
*** How to draw every interior pixel?
- process the scan line from the bottom to top
- find the intersection positions between the current scan line and the
  boundaries of fill region
- use coherence properties to reduce the process
- fill interior pixel in the odd intervals
** Methods for drawing polygons or curved objects
*** Scanline conversion of polygons
*** Boundary fill (boundary is one color)
- Start with drawn boundaries and an interior point
- Recursively recolor outward from that point
  - If neighbor is different, then recolor and recur
- Everyting within the boundary is changed to that color
*** flood fill (boundary may be different colors)
- Start with a point
- Define color under that point sas the interior color
- Recursively recolor outward from that poing
  - If neighbor is interior color, then recolor and recur
- Contiguous regions are re-colored
*** Boundary vs Flood-fill
- Both start with an interior pixel
- Boundary-fill requires annotating boundary pixels while flood-fill requires
  annotating interior pixels
- Both are appealing to fill in the irregular boundaries
** Reading
- 6-10 and 10-14
* Clipping lines
** Why Clip?
- Do not want to waste time drawing objects that are outside of the viewing
  window (or clipping window)
** Clipping points
- Given a point (x, y) and clipping window (xmin, ymin), (xmax, ymax)
- Determine if the point should be drawn
** Clipping lines
- Given a line with end-points (x0, y0), (x1, y1) and clipping window (xmin,
  ymin), (xmax, ymax)
- Determine
  - whether line should be drawn
  - clipped end-points of line to draw
** Simple Alg
- If both end points inside rect, draw line
- If one end-point outside,
- Intersect line with all edges of rectangle
  - clip the line segment outside the rect, and repeat test with rest of edges
*** Intersecting two lines
- parametric representation of the lines
  - t = 0 corresponds to (x0,y0)
  - t = 1 correspons to (x1, y1)
- Have a system of parametric equations to determine if there is an
  intersection and also to calculate the point of intersection
*** Disadvantages
- Lots of intersection tests makes alg expensive
- Complicated tests to determine if intersecting rectangle
- Is there a better way?
**** Trivial accepts
- big optimization
- How can we quickly decide whether the line segment is entirely inside window
- Answer: test both endpoints
**** Trivial rejects
- How to know if a line is outside of the window
- Answer: both endpoints on wrong side of the same edge, can trivially reject
  the line
** Cohen-Sutherland
*** Classify p0, p1 using region codes c0, c1
- Every end point is assigned to a four-digit binary value, i.e. region code
- Each bit position indicates whether the point is inside or outside of a
  specific window edges
| bit 4 | bit 3  | bit 2 | bit 1 |
|-------+--------+-------+-------|
| top   | bottom | right | left  |

| 1001 | 1000 | 1010 |
| 0001 | 0000 | 0010 |
| 0101 | 0100 | 0110 |
**** If c0 ^ c1 not 0
- bitwise and 0010 ^ 1011 = 0010
- trivially reject
**** If c0 bitwise or c1 not 0
- trivially accept because both points are not on wrong side for any edge
- bitwise or 0010 op 1011 = 1011
**** Otherwise reduce to trivial cases by splitting into two segments
*** Window intersection
- Similar to simple alg
*** Extends easiy to 3D line clipping
- 27 regions
- 6 bits
*** Summarize
- Use region codes to quickly eliminate/incude lines
  - *best algorithm when trivial accepts/rejects are common*
- Must compute viewing window clipping of remaining lines
- More efficient algs exist
  - non-trivial clipping cost
** Liang-Barsky
*** Parametric definition of a line
- x = x1 udeltax
- y = y1 udeltay
- deltax = (x2-x1)
- deltay = (y2-y1), 0<=u<=1
*** Lines are oriented: classify lines as moving inside to out or outside to in
- For lines stating outside, update its starting point
- For lines starting inside, update end point
- For lines paralleling the boundaries and outside, reject it
*** Goal find range of u for which x and y both inside the viewing window
*** Advantages
- Faster than cohen-sutherland
- Extension to 3D is easy
  - parametric rep for 3D lines
  - Compute u1, u2 based on the intersection between ine and plane
** More Complex clipping windows
- The clipping could be any polygon
- Both Cohen and Liang can be extended to any polygon as well curve clipping
** Required reqdings: HB 8-5, 8-6, 8-7, and 8-9
